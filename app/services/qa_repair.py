"""
QA Repair Agent - Automated Regeneration
Repairs failed chunks by regenerating content with strict validation
"""

import json
import os
import httpx
from typing import Dict, Any, Optional, List
from datetime import datetime
from services.supabase_client import ChunkRecord, supabase_service
from services.qa_agent import qa_agent
from services.openrouter import openrouter


class QARepairAgent:
    def __init__(self):
        self.max_attempts = 2

        # Allowed chunk types for regeneration
        self.allowed_types = ["procedure", "spec", "list", "part_location"]

    async def repair_chunk(self, chunk: ChunkRecord) -> Dict[str, Any]:
        """
        Attempt to repair a failed chunk
        Returns: {"status": "repaired"|"skipped"|"failed", "reason": "..."}
        """
        # 1. Check eligibility
        if chunk.chunk_type not in self.allowed_types:
            return {
                "status": "skipped",
                "reason": f"Chunk type '{chunk.chunk_type}' not eligible for auto-repair",
            }

        if chunk.regeneration_attempts >= self.max_attempts:
            return {
                "status": "skipped",
                "reason": f"Max regeneration attempts ({self.max_attempts}) reached",
            }

        # 2. Regenerate content
        new_data = await self._regenerate_content(chunk)
        if not new_data:
            return {"status": "failed", "reason": "LLM regeneration failed"}

        # 3. Validate new content (Rule-based only first)
        # Create a temporary chunk record for validation
        temp_chunk = ChunkRecord(
            {
                "id": chunk.id,
                "vehicle_key": chunk.vehicle_key,
                "content_id": chunk.content_id,
                "chunk_type": chunk.chunk_type,
                "data": new_data,
            }
        )

        qa_result = qa_agent._check_rules(temp_chunk)
        if qa_result["status"] == "fail":
            return {
                "status": "failed",
                "reason": f"Regenerated content failed QA rules: {qa_result['notes']}",
            }

        # 4. Update chunk in database
        # We set qa_status to "pending" so it goes through the full QA process (including LLM check) again
        success = await supabase_service.save_chunk(
            vehicle_key=chunk.vehicle_key,
            content_id=chunk.content_id,
            chunk_type=chunk.chunk_type,
            template_type=chunk.template_type,
            title=chunk.title,
            data=new_data,
            sources=chunk.sources,  # Keep original sources for now, or LLM could suggest new ones
            verification_status="pending_verification",
            source_confidence=chunk.source_confidence,
            qa_status="pending",
            qa_notes="Regenerated by QA Repair Agent",
            last_qa_reviewed_at=None,  # Reset review time
        )

        # We need to update regeneration metadata separately or ensure save_chunk handles it
        # Since save_chunk doesn't expose regeneration_attempts in the signature I added earlier (oops),
        # I'll do a direct update or modify save_chunk.
        # Actually, I'll just use a direct update for the metadata after save.

        if success:
            # Update regeneration metadata
            # We need a method to update specific fields or just use raw SQL/client
            # For now, let's assume save_chunk worked for the main data, and we'll patch the rest
            # Or better, let's update save_chunk signature in supabase_client.py to include regeneration_attempts
            # Wait, I did update save_chunk signature in the previous turn!
            # Let me check... Yes, I added regeneration_attempts to save_chunk.

            # So I can just call save_chunk with the new values.
            await supabase_service.save_chunk(
                vehicle_key=chunk.vehicle_key,
                content_id=chunk.content_id,
                chunk_type=chunk.chunk_type,
                template_type=chunk.template_type,
                title=chunk.title,
                data=new_data,
                sources=chunk.sources,
                verification_status="pending_verification",
                source_confidence=chunk.source_confidence,
                qa_status="pending",
                qa_notes="Regenerated by QA Repair Agent",
                regeneration_attempts=chunk.regeneration_attempts + 1,
                regenerated_at=datetime.utcnow().isoformat(),
            )

            return {
                "status": "repaired",
                "reason": "Content regenerated and passed initial rules",
            }
        else:
            return {"status": "failed", "reason": "Database save failed"}

    async def _regenerate_content(self, chunk: ChunkRecord) -> Optional[Dict[str, Any]]:
        """Request clean regeneration from LLM"""
        prompt = {
            "task": "REGENERATE_CHUNK",
            "vehicle": chunk.vehicle_key,
            "chunk_type": chunk.chunk_type,
            "topic": chunk.content_id,
            "title": chunk.title,
            "instructions": [
                "You are an expert automotive technician.",
                "Regenerate the content for this specific vehicle and topic.",
                "Do NOT use placeholders like 'See Manual'.",
                "Do NOT invent fluid capacities or torque specs unless you are 100% sure (use ranges if needed).",
                "Return ONLY valid JSON matching the chunk structure.",
                "Structure for 'spec': {'spec_items': [{'label': '...', 'value': '...', 'unit': '...'}]}",
                "Structure for 'procedure': {'steps': [{'title': '...', 'text': '...'}]}",
                "Structure for 'list': {'items': ['...']}",
                "Structure for 'part_location': {'location': '...', 'description': '...'}",
            ],
        }

        try:
            content, cost = await openrouter.chat_completion(
                "ingestion",
                [
                    {
                        "role": "system",
                        "content": "You are a strict automotive data generator. Output JSON only.",
                    },
                    {"role": "user", "content": json.dumps(prompt)},
                ],
                response_format={"type": "json_object"},
                timeout=45.0,
            )

            return json.loads(content)

        except Exception as e:
            print(f"‚ùå LLM regeneration exception: {e}")
            return None


qa_repair_agent = QARepairAgent()
